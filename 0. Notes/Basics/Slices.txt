// You can edit this code!
// Click here and start typing.
package main

import "fmt"

func main() {
	//slices are more flexible
	//dynamic length
	//definded by the nr of elems, not the length
	//passed by address

	//this is a empty slice
	var mySlice []int
	fmt.Println("values: ", mySlice)
	fmt.Println("is the slice nil?: ", mySlice == nil)

	//this is another slice
	//make(type, lenth, capacity(optional)
	anotherSlice := make([]int, 5)
	fmt.Println("values: ", anotherSlice)
	fmt.Println("is the slice nil?: ", anotherSlice == nil)

	//another way of initialization
	otherSlice := []int{1, 2, 3}
	fmt.Println("values: ", otherSlice)
	fmt.Println("is the slice nil?: ", otherSlice == nil)

	//setting elements inside slices
	otherSlice[1] = 5
	fmt.Println("values: ", otherSlice)
	fmt.Println("length: ", len(otherSlice))
	fmt.Println("capacity: ", cap(otherSlice))

	//appending to the slice
	//append returns another slice
	slice1 := []int{5, 9, 8, 10}
	slice1 = append(slice1, 2, 3, 5)
	fmt.Println("values: ", slice1)
	fmt.Println("length: ", len(slice1))
	fmt.Println("capacity: ", cap(slice1))

	//append a slice to another slice
	sliceToAppend := []int{1, 2, 3}
	sliceToAppend = append(sliceToAppend, otherSlice...)
	fmt.Println("values: ", sliceToAppend)
	fmt.Println("length: ", len(sliceToAppend))
	fmt.Println("capacity: ", cap(sliceToAppend))

	//copy a slice
	sl := make([]int, 5)
	el := copy(sl, sliceToAppend)
	fmt.Println("values: ", sl)
	fmt.Println("length: ", len(sl))
	fmt.Println("capacity: ", cap(sl))
	fmt.Println("values: ", el)

	//selecting from slice
	cutslice := sl[2:4]
	//[:5]	//form beginning till 5th el)
	//[0:]	//0 till end
	fmt.Println("values: ", cutslice)
	
	
	//OBS
	//slices are based on arrays under the hood
	//they are passed by reference, not by value
	//any modification done within a function, stays permanent

}